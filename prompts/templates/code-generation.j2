# Code Generation Prompt Template

## Purpose
Generate production-ready code following project conventions and best practices.

## Template Variables
- `{{language}}`: Programming language (python, typescript, go, etc.)
- {{framework}}: Framework to use (fastapi, react, gin, etc.)
- {{task_description}}: What the code should do
- {{requirements}}: Functional requirements
- {{constraints}}: Performance, security, or other constraints
- {{examples}}: Input/output examples if applicable

## Prompt Structure

```
You are a expert {{language}} developer specializing in {{framework}}.

## Task
Generate {{task_description}}

## Requirements
{{requirements}}

## Constraints
{{constraints}}

## Code Standards
- Follow {{language}} best practices and style guides
- Include comprehensive error handling
- Add inline comments for complex logic
- Write unit tests for all public functions
- Include type hints (for typed languages)
- Handle edge cases and validation

## Output Format
Provide a single file with:
1. Imports and dependencies
2. Main code implementation
3. Example usage (if applicable)
4. Unit tests

## Example Output
\`\`\`{{language}}
# Your code here
\`\`\`

## Validation Checklist
Before responding, verify:
- [ ] Code compiles/runs without errors
- [ ] Handles all requirements
- [ ] Includes error handling
- [ ] Has appropriate logging
- [ ] Follows security best practices
- [ ] Is production-ready (not prototype)

Generate the code now.
```

## Usage Example
```
You are an expert Python developer specializing in FastAPI.

## Task
Generate a REST API endpoint for user authentication

## Requirements
- Accept email and password
- Return JWT token on success
- Rate limit: 5 attempts per minute
- Return 401 on invalid credentials

## Constraints
- Use Python 3.10+
- Maximum response time: 200ms
- Follow OWASP auth guidelines

## Code Standards
- Include Pydantic models
- Add structured logging
- Use async/await
```

## Generated Output Example
```python
from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, EmailStr
from datetime import datetime, timedelta
from typing import Optional
import jwt
import logging

router = APIRouter(prefix="/auth", tags=["authentication"])

logger = logging.getLogger(__name__)

class LoginRequest(BaseModel):
    email: EmailStr
    password: str

class TokenResponse(BaseModel):
    access_token: str
    token_type: str
    expires_in: int

SECRET_KEY = "your-secret-key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=30))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

@router.post("/login", response_model=TokenResponse)
async def login(request: LoginRequest):
    logger.info(f"Login attempt for {request.email}")
    
    # Verify credentials (simplified - use proper auth in production)
    user = authenticate_user(request.email, request.password)
    if not user:
        logger.warning(f"Failed login attempt for {request.email}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token = create_access_token(
        data={"sub": user.email, "roles": user.roles}
    )
    
    logger.info(f"Successful login for {request.email}")
    return {
        "access_token": access_token,
        "token_type": "bearer",
        "expires_in": ACCESS_TOKEN_EXPIRE_MINUTES * 60,
    }
```
